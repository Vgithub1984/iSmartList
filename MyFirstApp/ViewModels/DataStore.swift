//
//  DataStore.swift
//  MyFirstApp
//
//  This file contains the core data management logic for the iSmartList application.
//  It provides a centralized data store that manages shopping lists and their items,
//  with support for CRUD operations, persistence, and data synchronization.
//
//  Key Features:
//  - Manages shopping lists and items with full CRUD operations
//  - Supports soft deletion and recovery of lists
//  - Automatically persists data to UserDefaults
//  - Provides computed properties for filtered views
//  - Notifies observers of changes using @Published properties
//  - Thread-safe operations with proper state management

import Foundation
import SwiftUI
import Combine

// MARK: - Data Models

// MARK: - ItemRow

/// Represents an individual item within a shopping list.
///
/// This model is used to track individual shopping items, their completion status,
/// and metadata about when they were created and last modified. It's designed to work
/// seamlessly with SwiftUI's state management and supports persistence through Codable.
///
/// - Note: All properties are mutable to support editing functionality.
/// - Important: The `id` property is used for list diffing in SwiftUI. Changing it may cause UI issues.
///
/// ## Example
/// ```swift
/// let item = ItemRow(name: "Milk", isCompleted: false)
/// ```
public struct ItemRow: Identifiable, Codable, Hashable {
    // MARK: - Properties
    
    /// A unique identifier for the item.
    /// - Important: Used by SwiftUI for view updates. Should be unique across all items.
    public var id = UUID()
    
    /// The display name of the item.
    /// - Note: This is the primary user-facing text for the item.
    public var name: String
    
    /// Tracks whether the item has been marked as completed.
    /// - Note: Defaults to `false` for new items.
    public var isCompleted: Bool = false
    
    /// The date and time when the item was created.
    /// - Note: Automatically set to the current date when initialized.
    public var createdAt: Date = Date()
    
    /// The date and time when the item was last modified.
    /// - Note: Should be updated whenever any property changes.
    public var updatedAt: Date = Date()
    
    // MARK: - Initialization
    
    /// Creates a new shopping list item with the specified properties.
    /// - Parameters:
    ///   - id: A unique identifier for the item. A new UUID is generated by default.
    ///   - name: The display name of the item. This is the only required parameter.
    ///   - isCompleted: The completion status of the item. Defaults to `false`.
    ///   - createdAt: The creation timestamp. Defaults to the current date.
    ///   - updatedAt: The last update timestamp. Defaults to the current date.
    public init(id: UUID = UUID(), 
                name: String, 
                isCompleted: Bool = false, 
                createdAt: Date = Date(), 
                updatedAt: Date = Date()) {
        self.id = id
        self.name = name
        self.isCompleted = isCompleted
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

// MARK: - MyList

/// Represents a shopping list containing multiple items.
///
/// This model serves as a container for shopping items, with support for soft deletion
/// and metadata tracking. It's designed to work with SwiftUI's state management system
/// and supports persistence through Codable.
///
/// - Note: All properties are mutable to support editing functionality.
/// - Important: The `id` property is used for list diffing in SwiftUI. Changing it may cause UI issues.
///
/// ## Example
/// ```swift
/// let list = MyList(name: "Grocery List", items: [ItemRow(name: "Milk")])
/// ```
public struct MyList: Identifiable, Codable, Hashable {
    // MARK: - Properties
    
    /// A unique identifier for the list.
    /// - Important: Used by SwiftUI for view updates. Should be unique across all lists.
    public var id = UUID()
    
    /// The display name of the list.
    /// - Note: This is the primary user-facing text for the list.
    public var name: String
    
    /// The items contained in this list.
    /// - Note: This array can be empty if the list has no items.
    public var items: [ItemRow]
    
    /// A flag indicating whether the list has been soft-deleted.
    /// - Note: Soft-deleted lists can be restored using `DataStore.restoreList(_:)`.
    public var isDeleted: Bool = false
    
    /// The date and time when the list was created.
    /// - Note: Automatically set to the current date when initialized.
    public var createdAt: Date
    
    /// The date and time when the list was last modified.
    /// - Note: Should be updated whenever the list or any of its items change.
    public var updatedAt: Date
    
    // MARK: - Initialization
    
    /// Creates a new shopping list with the specified properties.
    /// - Parameters:
    ///   - id: A unique identifier for the list. A new UUID is generated by default.
    ///   - name: The display name of the list.
    ///   - items: The initial items in the list. Defaults to an empty array.
    ///   - isDeleted: The soft-delete status of the list. Defaults to `false`.
    ///   - updatedAt: The last update timestamp. Defaults to the current date.
    public init(id: UUID = UUID(),
                name: String,
                items: [ItemRow] = [],
                isDeleted: Bool = false,
                createdAt: Date = Date(),
                updatedAt: Date = Date()) {
        self.id = id
        self.name = name
        self.items = items
        self.isDeleted = isDeleted
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
    
    /// The number of completed items in the list.
    public var completedItemsCount: Int {
        items.filter { $0.isCompleted }.count
    }
    
    /// The total number of items in the list.
    public var totalItemsCount: Int {
        items.count
    }
    
    /// The completion percentage of the list (0.0 to 1.0).
    public var completionPercentage: Double {
        totalItemsCount > 0 ? Double(completedItemsCount) / Double(totalItemsCount) : 0
    }
}

// MARK: - DataStore

/// A centralized data management class that handles all application state and persistence.
///
/// This class serves as the single source of truth for all shopping list data in the app.
/// It handles data persistence, provides CRUD operations, and notifies observers of changes.
///
/// ## Key Responsibilities
/// - Manages the collection of shopping lists and their items
/// - Handles CRUD operations for both lists and items
/// - Automatically persists data to UserDefaults
/// - Provides computed properties for filtered views (active/deleted lists)
/// - Manages soft deletion and restoration of lists
/// - Notifies observers of changes using @Published properties
///
/// - Note: This class is designed to be used as an `@EnvironmentObject` throughout the app.
/// - Important: All modifications to the data should be made through this class to ensure
///   proper state management and persistence.
///
/// ## Usage
/// ```swift
/// // In your view:
/// @EnvironmentObject var dataStore: DataStore
/// 
/// // To access active lists:
/// ForEach(dataStore.activeLists) { list in
///     // Display list
/// }
/// 
/// // To add a new list:
/// dataStore.addList(MyList(name: "My New List"))
/// ```
public class DataStore: ObservableObject {
    // MARK: - Properties
    
    @Published public var userName: String = "Vicky Patel"
    
    /// The collection of all shopping lists, including both active and deleted ones.
    /// - Note: Use filtered computed properties for specific views.
    /// - Important: Always modify this through the provided methods to ensure proper state updates.
    @Published public var lists: [MyList] = []
    
    /// Returns an array of all lists (including deleted, zero item, active, completed).
    var totalLists: [MyList] { lists }
    
    /// Returns lists that are not deleted, have >0 items, and all items are completed.
    var completedLists: [MyList] {
        lists.filter { !$0.isDeleted && !$0.items.isEmpty && $0.items.allSatisfy { $0.isCompleted } }
    }
    
    /// Returns lists that are not deleted, have >0 items, and not all items are completed.
    var activeLists: [MyList] {
        lists.filter { !$0.isDeleted && !$0.items.isEmpty && $0.items.contains(where: { !$0.isCompleted }) }
    }
    
    /// Returns lists that are not deleted and have zero items.
    var zeroItemLists: [MyList] {
        lists.filter { !$0.isDeleted && $0.items.isEmpty }
    }
    
    /// Returns lists that are marked as deleted.
    var deletedLists: [MyList] {
        lists.filter { $0.isDeleted }
    }
    
    /// The counts for each mutually exclusive category.
    var totalListsCount: Int { lists.count }
    var completedListsCount: Int { completedLists.count }
    var activeListsCount: Int { activeLists.count }
    var zeroItemListsCount: Int { zeroItemLists.count }
    var deletedListsCount: Int { deletedLists.count }
    
    /// The key used to persist data in UserDefaults.
    /// - Note: Changing this will cause the app to lose access to previously saved data.
    private let saveKey = "savedLists"
    
    // MARK: - User Management
    
    /// Updates the user's name
    /// - Parameter newName: The new name to set
    public func updateUserName(_ newName: String) {
        userName = newName
        save()
    }
    
    // MARK: - Initialization
    
    /// Initializes a new DataStore instance and loads any saved data.
    /// - Note: Automatically loads persisted data from UserDefaults on initialization.
    public init() {
        load()
    }
    
    // MARK: - Persistence
    
    /// Loads saved lists from UserDefaults.
    ///
    /// This method attempts to load previously saved shopping lists from persistent storage.
    /// If no saved data exists, is corrupted, or cannot be decoded, it initializes with an empty array.
    ///
    /// - Note: This method is called automatically during initialization.
    /// - Important: This method will silently fail and return an empty array if the data is corrupted.
    private func load() {
        if let data = UserDefaults.standard.data(forKey: saveKey) {
            if let decoded = try? JSONDecoder().decode([MyList].self, from: data) {
                lists = decoded
                return
            }
        }
        lists = []
    }
    
    /// Persists the current list data to UserDefaults.
    ///
    /// This method encodes the current list data to JSON and saves it to UserDefaults.
    /// It's called automatically after any modification to the data to ensure persistence.
    ///
    /// - Note: This method is called automatically after any modification to the data.
    /// - Important: The save operation is synchronous and may block the main thread briefly.
    ///   For large datasets, consider optimizing with background queue if performance becomes an issue.
    public func save() {
        if let encoded = try? JSONEncoder().encode(lists) {
            UserDefaults.standard.set(encoded, forKey: saveKey)
            // Force immediate synchronization (optional, can be removed if not needed)
            UserDefaults.standard.synchronize()
        }
    }
    
    // MARK: - CRUD Operations
    
    // MARK: List Operations
    
    /// Adds a new shopping list to the data store.
    ///
    /// This method adds a new list to the collection, automatically setting its creation
    /// and update timestamps to the current date. The list will be persisted immediately.
    ///
    /// - Parameter list: The list to add to the data store.
    /// - Note: The list's `createdAt` and `updatedAt` timestamps will be updated to the current date.
    /// - Important: This method triggers a save operation, which persists the changes to disk.
    func addList(_ list: MyList) {
        var newList = list
        newList.createdAt = Date()
        newList.updatedAt = Date()
        lists.append(newList)
        save()
    }
    
    /// Updates an existing list in the data store.
    ///
    /// This method finds a list with a matching ID and replaces it with the provided list,
    /// automatically updating the `updatedAt` timestamp to the current date.
    ///
    /// - Parameter list: The updated list with the same ID as the list to update.
    /// - Note: The list's `updatedAt` timestamp will be updated to the current date.
    /// - Important: If no list with a matching ID is found, this method does nothing.
    func updateList(_ list: MyList) {
        if let index = lists.firstIndex(where: { $0.id == list.id }) {
            var updatedList = list
            updatedList.updatedAt = Date()
            lists[index] = updatedList
            save()
        }
    }
    
    /// Deletes lists at the specified offsets.
    ///
    /// - Warning: ⚠️ This method performs a hard delete and cannot be undone.
    ///   Consider using `softDeleteList(_:)` instead for a recoverable delete.
    ///
    /// - Parameter offsets: The index set of lists to delete.
    /// - Note: This method is deprecated. Use `softDeleteList(_:)` for safer deletion.
    @available(*, deprecated, message: "Use softDeleteList(_:) for safer deletion that allows recovery")
    func deleteList(at offsets: IndexSet) {
        lists.remove(atOffsets: offsets)
        save()
    }
    
    /// Deletes the specified list.
    ///
    /// - Warning: ⚠️ This method is deprecated. Use `softDeleteList(_:)` or `hardDeleteList(_:)`
    ///   to explicitly indicate the type of deletion you want to perform.
    ///
    /// - Parameter list: The list to delete.
    @available(*, deprecated, message: "Use softDeleteList(_:) or hardDeleteList(_:) explicitly")
    func deleteList(_ list: MyList) {
        softDeleteList(list)
    }
    
    // MARK: - List Item Operations
    
    /// Adds a new item to the specified shopping list.
    ///
    /// This method adds an item to the specified list, automatically setting its creation
    /// and update timestamps. The parent list's `updatedAt` timestamp is also updated.
    ///
    /// - Parameters:
    ///   - item: The item to add to the list.
    ///   - list: The list to which the item should be added.
    ///
    /// - Note: If the specified list is not found, this method does nothing.
    /// - Important: This method triggers a save operation, persisting changes to disk.
    func addItem(_ item: ItemRow, to list: MyList) {
        guard let index = lists.firstIndex(where: { $0.id == list.id }) else { return }
        var updatedList = lists[index]
        var newItem = item
        newItem.createdAt = Date()
        newItem.updatedAt = Date()
        updatedList.items.append(newItem)
        updatedList.updatedAt = Date()
        lists[index] = updatedList
        save()
    }
    
    /// Updates an existing item within a shopping list.
    ///
    /// This method finds an item by ID within the specified list and updates it with
    /// the provided values, automatically updating timestamps for both the item and the parent list.
    ///
    /// - Parameters:
    ///   - item: The updated item data (must have the same ID as an existing item).
    ///   - list: The list containing the item to be updated.
    ///
    /// - Note: If either the list or the item is not found, this method does nothing.
    /// - Important: The item's `updatedAt` timestamp will be set to the current date.
    func updateItem(_ item: ItemRow, in list: MyList) {
        guard let listIndex = lists.firstIndex(where: { $0.id == list.id }) else { return }
        if let itemIndex = lists[listIndex].items.firstIndex(where: { $0.id == item.id }) {
            var updatedList = lists[listIndex]
            var updatedItem = item
            updatedItem.updatedAt = Date()
            updatedList.items[itemIndex] = updatedItem
            updatedList.updatedAt = Date()
            lists[listIndex] = updatedList
            save()
        }
    }
    
    /// Permanently deletes an item from the specified shopping list.
    ///
    /// - Warning: ⚠️ This is a hard delete operation. The item will be permanently
    ///   removed from the list and cannot be recovered.
    ///
    /// - Parameters:
    ///   - item: The item to delete.
    ///   - list: The list from which to remove the item.
    ///
    /// - Note: If the specified list is not found, this method does nothing.
    /// - Important: The parent list's `updatedAt` timestamp will be updated.
    func deleteItem(_ item: ItemRow, from list: MyList) {
        guard let index = lists.firstIndex(where: { $0.id == list.id }) else { return }
        var updatedList = lists[index]
        updatedList.items.removeAll { $0.id == item.id }
        updatedList.updatedAt = Date()
        lists[index] = updatedList
        save()
    }
    
    // MARK: - Deleted Lists Management
    
    /// Moves a list to the trash by marking it as deleted.
    ///
    /// This method performs a soft delete by setting the list's `isDeleted` flag to `true`.
    /// The list remains in the data store but is filtered out of the main interface.
    ///
    /// - Parameter list: The list to be soft-deleted.
    /// - Note: The list can be restored using `restoreList(_:)`.
    /// - Important: This method updates the list's `updatedAt` timestamp.
    func softDeleteList(_ list: MyList) {
        if let index = lists.firstIndex(where: { $0.id == list.id }) {
            var updatedList = lists[index]
            updatedList.isDeleted = true
            updatedList.updatedAt = Date()
            updateList(updatedList)
        }
    }
    
    /// Restores a soft-deleted list by marking it as not deleted.
    ///
    /// This method reverses a soft delete by setting the list's `isDeleted` flag to `false`,
    /// making it appear in the main lists view again.
    ///
    /// - Parameter list: The list to be restored.
    /// - Note: The list's `updatedAt` timestamp will be updated to the current date.
    func restoreList(_ list: MyList) {
        if let index = lists.firstIndex(where: { $0.id == list.id }) {
            var updatedList = lists[index]
            updatedList.isDeleted = false
            updatedList.updatedAt = Date()
            updateList(updatedList)
        }
    }
    
    /// Permanently deletes a list from the data store.
    ///
    /// - Warning: ⚠️ This action cannot be undone. The list and all its items will be
    ///   permanently removed from the data store.
    ///
    /// - Parameter list: The list to be permanently deleted.
    /// - Note: For safer deletion that allows recovery, use `softDeleteList(_:)` instead.
    /// - Important: This operation is immediate and permanent. There is no confirmation dialog.
    func permanentDelete(_ list: MyList) {
        lists.removeAll { $0.id == list.id }
        save()
    }
    
    /// Permanently removes all soft-deleted lists from the data store.
    ///
    /// - Warning: ⚠️ This action cannot be undone. All lists marked as deleted will be
    ///   permanently removed from the data store.
    ///
    /// - Note: This is typically called when the user chooses to empty the trash.
    /// - Important: This operation is immediate and permanent. There is no confirmation dialog.
    func emptyTrash() {
        lists.removeAll { $0.isDeleted }
        save()
    }
}

// MARK: - Data Models

// All data models are now defined at the top of the file for better organization


